Subject: [PATCH] Backport enhanced VT from 6.1

The 6.0.1's VT has a broken implementation and handles HEVC in an inefficient way for VT.
This backport brings full range color and HDR passthrough for VideoToolbox

---
diff --git tests/fate/hevc.mak tests/fate/hevc.mak
index 20c2e5b..c5df8ea 100644
--- tests/fate/hevc.mak
+++ tests/fate/hevc.mak
@@ -222,7 +222,7 @@ FATE_HEVC-$(call ALLYES, HEVC_DEMUXER MOV_DEMUXER HEVC_PARSER HEVC_MP4TOANNEXB_B
 fate-hevc-bsf-mp4toannexb: tests/data/hevc-mp4.mov
 fate-hevc-bsf-mp4toannexb: CMD = md5 -i $(TARGET_PATH)/tests/data/hevc-mp4.mov -c:v copy -fflags +bitexact -f hevc
 fate-hevc-bsf-mp4toannexb: CMP = oneline
-fate-hevc-bsf-mp4toannexb: REF = 1873662a3af1848c37e4eb25722c8df9
+fate-hevc-bsf-mp4toannexb: REF = 7d05a79c7a6665ae22c0043a4d83a811

 fate-hevc-skiploopfilter: CMD = framemd5 -skip_loop_filter nokey -i $(TARGET_SAMPLES)/hevc-conformance/SAO_D_Samsung_5.bit -sws_flags bitexact
 FATE_HEVC-$(call FRAMEMD5, HEVC, HEVC, HEVC_PARSER) += fate-hevc-skiploopfilter
--
Index: libavutil/hwcontext_videotoolbox.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git libavutil/hwcontext_videotoolbox.h libavutil/hwcontext_videotoolbox.h
--- libavutil/hwcontext_videotoolbox.h	(revision e389681a74defdcd337ac32b61a41aed34009fc8)
+++ libavutil/hwcontext_videotoolbox.h	(date 1708790792432)
@@ -39,9 +39,12 @@
  * depending on application usage, so it is preferable to let CoreVideo manage
  * the pool using the default implementation.
  *
- * Currently AVHWDeviceContext.hwctx and AVHWFramesContext.hwctx are always
- * NULL.
+ * Currently AVHWDeviceContext.hwctx are always NULL.
  */
+
+typedef struct AVVTFramesContext {
+    enum AVColorRange color_range;
+} AVVTFramesContext;

 /**
  * Convert a VideoToolbox (actually CoreVideo) format to AVPixelFormat.
Index: libavutil/hwcontext_videotoolbox.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git libavutil/hwcontext_videotoolbox.c libavutil/hwcontext_videotoolbox.c
--- libavutil/hwcontext_videotoolbox.c	(revision e389681a74defdcd337ac32b61a41aed34009fc8)
+++ libavutil/hwcontext_videotoolbox.c	(date 1708790750454)
@@ -43,6 +43,7 @@
     enum AVPixelFormat pix_fmt;
 } cv_pix_fmts[] = {
     { kCVPixelFormatType_420YpCbCr8Planar,              false, AV_PIX_FMT_YUV420P },
+    { kCVPixelFormatType_420YpCbCr8PlanarFullRange,     true,  AV_PIX_FMT_YUV420P },
     { kCVPixelFormatType_422YpCbCr8,                    false, AV_PIX_FMT_UYVY422 },
     { kCVPixelFormatType_32BGRA,                        true,  AV_PIX_FMT_BGRA },
 #ifdef kCFCoreFoundationVersionNumber10_7
@@ -144,6 +145,25 @@
     return AV_PIX_FMT_NONE;
 }

+static uint32_t vt_format_from_pixfmt(enum AVPixelFormat pix_fmt,
+                                      enum AVColorRange range)
+{
+    for (int i = 0; i < FF_ARRAY_ELEMS(cv_pix_fmts); i++) {
+        if (cv_pix_fmts[i].pix_fmt == pix_fmt) {
+            int full_range = (range == AVCOL_RANGE_JPEG);
+
+            // Don't care if unspecified
+            if (range == AVCOL_RANGE_UNSPECIFIED)
+                return cv_pix_fmts[i].cv_fmt;
+
+            if (cv_pix_fmts[i].full_range == full_range)
+                return cv_pix_fmts[i].cv_fmt;
+        }
+    }
+
+    return 0;
+}
+
 uint32_t av_map_videotoolbox_format_from_pixfmt(enum AVPixelFormat pix_fmt)
 {
     return av_map_videotoolbox_format_from_pixfmt2(pix_fmt, false);
@@ -151,12 +171,7 @@

 uint32_t av_map_videotoolbox_format_from_pixfmt2(enum AVPixelFormat pix_fmt, bool full_range)
 {
-    int i;
-    for (i = 0; i < FF_ARRAY_ELEMS(cv_pix_fmts); i++) {
-        if (cv_pix_fmts[i].pix_fmt == pix_fmt && cv_pix_fmts[i].full_range == full_range)
-            return cv_pix_fmts[i].cv_fmt;
-    }
-    return 0;
+    return vt_format_from_pixfmt(pix_fmt, full_range ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG);
 }

 static int vt_pool_alloc(AVHWFramesContext *ctx)
@@ -166,6 +181,7 @@
     CFNumberRef w, h, pixfmt;
     uint32_t cv_pixfmt;
     CFMutableDictionaryRef attributes, iosurface_properties;
+    AVVTFramesContext *hw_ctx = ctx->hwctx;

     attributes = CFDictionaryCreateMutable(
         NULL,
@@ -173,7 +189,7 @@
         &kCFTypeDictionaryKeyCallBacks,
         &kCFTypeDictionaryValueCallBacks);

-    cv_pixfmt = av_map_videotoolbox_format_from_pixfmt(ctx->sw_format);
+    cv_pixfmt = vt_format_from_pixfmt(ctx->sw_format, hw_ctx->color_range);
     pixfmt = CFNumberCreate(NULL, kCFNumberSInt32Type, &cv_pixfmt);
     CFDictionarySetValue(
         attributes,
@@ -740,6 +756,14 @@
         return AVERROR_UNKNOWN;
     }

+    return 0;
+}
+
+static int vt_device_derive(AVHWDeviceContext *device_ctx,
+                            AVHWDeviceContext *src_ctx, AVDictionary *opts,
+                            int flags)
+{
+    // There is no context to be setup with VT, just return.
     return 0;
 }

@@ -750,6 +774,8 @@
     .frames_priv_size     = sizeof(VTFramesContext),

     .device_create        = vt_device_create,
+    .device_derive        = vt_device_derive,
+    .frames_hwctx_size    = sizeof(AVVTFramesContext),
     .frames_init          = vt_frames_init,
     .frames_get_buffer    = vt_get_buffer,
     .frames_get_constraints = vt_frames_get_constraints,
Index: libavcodec/videotoolboxenc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git libavcodec/videotoolboxenc.c libavcodec/videotoolboxenc.c
--- libavcodec/videotoolboxenc.c	(revision e389681a74defdcd337ac32b61a41aed34009fc8)
+++ libavcodec/videotoolboxenc.c	(date 1708796449800)
@@ -37,6 +37,7 @@
 #include "encode.h"
 #include "h264.h"
 #include "h264_sei.h"
+#include "hwconfig.h"
 #include <dlfcn.h>

 #if !HAVE_KCMVIDEOCODECTYPE_HEVC
@@ -63,7 +64,21 @@
                                            size_t *parameterSetCountOut,
                                            int *NALUnitHeaderLengthOut);

-//These symbols may not be present
+/*
+ * Symbols that aren't available in MacOS 10.8 and iOS 8.0 need to be accessed
+ * from compat_keys, or it will cause compiler errors when compiling for older
+ * OS versions.
+ *
+ * For example, kVTCompressionPropertyKey_H264EntropyMode was added in
+ * MacOS 10.9. If this constant were used directly, a compiler would generate
+ * an error when it has access to the MacOS 10.8 headers, but does not have
+ * 10.9 headers.
+ *
+ * Runtime errors will still occur when unknown keys are set. A warning is
+ * logged and encoding continues where possible.
+ *
+ * When adding new symbols, they should be loaded/set in loadVTEncSymbols().
+ */
 static struct{
     CFStringRef kCVImageBufferColorPrimaries_ITU_R_2020;
     CFStringRef kCVImageBufferTransferFunction_ITU_R_2020;
@@ -94,6 +109,8 @@
     CFStringRef kVTProfileLevel_H264_High_AutoLevel;
     CFStringRef kVTProfileLevel_H264_Extended_5_0;
     CFStringRef kVTProfileLevel_H264_Extended_AutoLevel;
+    CFStringRef kVTProfileLevel_H264_ConstrainedBaseline_AutoLevel;
+    CFStringRef kVTProfileLevel_H264_ConstrainedHigh_AutoLevel;

     CFStringRef kVTProfileLevel_HEVC_Main_AutoLevel;
     CFStringRef kVTProfileLevel_HEVC_Main10_AutoLevel;
@@ -102,9 +119,16 @@
     CFStringRef kVTCompressionPropertyKey_TargetQualityForAlpha;
     CFStringRef kVTCompressionPropertyKey_PrioritizeEncodingSpeedOverQuality;
     CFStringRef kVTCompressionPropertyKey_ConstantBitRate;
+    CFStringRef kVTCompressionPropertyKey_EncoderID;

     CFStringRef kVTVideoEncoderSpecification_EnableHardwareAcceleratedVideoEncoder;
     CFStringRef kVTVideoEncoderSpecification_RequireHardwareAcceleratedVideoEncoder;
+    CFStringRef kVTVideoEncoderSpecification_EnableLowLatencyRateControl;
+    CFStringRef kVTCompressionPropertyKey_AllowOpenGOP;
+    CFStringRef kVTCompressionPropertyKey_MaximizePowerEfficiency;
+    CFStringRef kVTCompressionPropertyKey_ReferenceBufferCount;
+    CFStringRef kVTCompressionPropertyKey_MaxAllowedFrameQP;
+    CFStringRef kVTCompressionPropertyKey_MinAllowedFrameQP;

     getParameterSetAtIndex CMVideoFormatDescriptionGetHEVCParameterSetAtIndex;
 } compat_keys;
@@ -120,7 +144,7 @@

 static pthread_once_t once_ctrl = PTHREAD_ONCE_INIT;

-static void loadVTEncSymbols(){
+static void loadVTEncSymbols(void){
     compat_keys.CMVideoFormatDescriptionGetHEVCParameterSetAtIndex =
         (getParameterSetAtIndex)dlsym(
             RTLD_DEFAULT,
@@ -156,6 +180,8 @@
     GET_SYM(kVTProfileLevel_H264_High_AutoLevel,     "H264_High_AutoLevel");
     GET_SYM(kVTProfileLevel_H264_Extended_5_0,       "H264_Extended_5_0");
     GET_SYM(kVTProfileLevel_H264_Extended_AutoLevel, "H264_Extended_AutoLevel");
+    GET_SYM(kVTProfileLevel_H264_ConstrainedBaseline_AutoLevel, "H264_ConstrainedBaseline_AutoLevel");
+    GET_SYM(kVTProfileLevel_H264_ConstrainedHigh_AutoLevel,     "H264_ConstrainedHigh_AutoLevel");

     GET_SYM(kVTProfileLevel_HEVC_Main_AutoLevel,     "HEVC_Main_AutoLevel");
     GET_SYM(kVTProfileLevel_HEVC_Main10_AutoLevel,   "HEVC_Main10_AutoLevel");
@@ -166,21 +192,24 @@
     GET_SYM(kVTCompressionPropertyKey_PrioritizeEncodingSpeedOverQuality,
             "PrioritizeEncodingSpeedOverQuality");
     GET_SYM(kVTCompressionPropertyKey_ConstantBitRate, "ConstantBitRate");
+    GET_SYM(kVTCompressionPropertyKey_EncoderID, "EncoderID");

     GET_SYM(kVTVideoEncoderSpecification_EnableHardwareAcceleratedVideoEncoder,
             "EnableHardwareAcceleratedVideoEncoder");
     GET_SYM(kVTVideoEncoderSpecification_RequireHardwareAcceleratedVideoEncoder,
             "RequireHardwareAcceleratedVideoEncoder");
+    GET_SYM(kVTVideoEncoderSpecification_EnableLowLatencyRateControl,
+            "EnableLowLatencyRateControl");
+    GET_SYM(kVTCompressionPropertyKey_AllowOpenGOP, "AllowOpenGOP");
+    GET_SYM(kVTCompressionPropertyKey_MaximizePowerEfficiency,
+            "MaximizePowerEfficiency");
+    GET_SYM(kVTCompressionPropertyKey_ReferenceBufferCount,
+            "ReferenceBufferCount");
+    GET_SYM(kVTCompressionPropertyKey_MaxAllowedFrameQP, "MaxAllowedFrameQP");
+    GET_SYM(kVTCompressionPropertyKey_MinAllowedFrameQP, "MinAllowedFrameQP");
 }

-typedef enum VT_H264Profile {
-    H264_PROF_AUTO,
-    H264_PROF_BASELINE,
-    H264_PROF_MAIN,
-    H264_PROF_HIGH,
-    H264_PROF_EXTENDED,
-    H264_PROF_COUNT
-} VT_H264Profile;
+#define H264_PROFILE_CONSTRAINED_HIGH (FF_PROFILE_H264_HIGH | FF_PROFILE_H264_CONSTRAINED)

 typedef enum VTH264Entropy{
     VT_ENTROPY_NOT_SET,
@@ -188,18 +217,11 @@
     VT_CABAC
 } VTH264Entropy;

-typedef enum VT_HEVCProfile {
-    HEVC_PROF_AUTO,
-    HEVC_PROF_MAIN,
-    HEVC_PROF_MAIN10,
-    HEVC_PROF_COUNT
-} VT_HEVCProfile;
-
 static const uint8_t start_code[] = { 0, 0, 0, 1 };

 typedef struct ExtraSEI {
-  void *data;
-  size_t size;
+    void *data;
+    size_t size;
 } ExtraSEI;

 typedef struct BufNode {
@@ -213,6 +235,7 @@
     AVClass *class;
     enum AVCodecID codec_id;
     VTCompressionSessionRef session;
+    CFDictionaryRef supported_props;
     CFStringRef ycbcr_matrix;
     CFStringRef color_primaries;
     CFStringRef transfer_function;
@@ -232,7 +255,7 @@
     int64_t first_pts;
     int64_t dts_delta;

-    int64_t profile;
+    int profile;
     int level;
     int entropy;
     int realtime;
@@ -251,8 +274,47 @@

     /* can't be bool type since AVOption will access it as int */
     int a53_cc;
+
+    int max_slice_bytes;
+    int power_efficient;
+    int max_ref_frames;
 } VTEncContext;

+static int vt_dump_encoder(AVCodecContext *avctx)
+{
+    VTEncContext *vtctx = avctx->priv_data;
+    CFStringRef encoder_id = NULL;
+    int status;
+    CFIndex length, max_size;
+    char *name;
+
+    status = VTSessionCopyProperty(vtctx->session,
+                                   compat_keys.kVTCompressionPropertyKey_EncoderID,
+                                   kCFAllocatorDefault,
+                                   &encoder_id);
+    // OK if not supported
+    if (status != noErr)
+        return 0;
+
+    length = CFStringGetLength(encoder_id);
+    max_size = CFStringGetMaximumSizeForEncoding(length, kCFStringEncodingUTF8);
+    name = av_malloc(max_size);
+    if (!name) {
+        CFRelease(encoder_id);
+        return AVERROR(ENOMEM);
+    }
+
+    CFStringGetCString(encoder_id,
+                       name,
+                       max_size,
+                       kCFStringEncodingUTF8);
+    av_log(avctx, AV_LOG_DEBUG, "Init the encoder: %s\n", name);
+    av_freep(&name);
+    CFRelease(encoder_id);
+
+    return 0;
+}
+
 static int vtenc_populate_extradata(AVCodecContext   *avctx,
                                     CMVideoCodecType codec_type,
                                     CFStringRef      profile_level,
@@ -298,6 +360,34 @@
     set_async_error(vtctx, 0);
 }

+static void vtenc_reset(VTEncContext *vtctx)
+{
+    if (vtctx->session) {
+        CFRelease(vtctx->session);
+        vtctx->session = NULL;
+    }
+
+    if (vtctx->supported_props) {
+        CFRelease(vtctx->supported_props);
+        vtctx->supported_props = NULL;
+    }
+
+    if (vtctx->color_primaries) {
+        CFRelease(vtctx->color_primaries);
+        vtctx->color_primaries = NULL;
+    }
+
+    if (vtctx->transfer_function) {
+        CFRelease(vtctx->transfer_function);
+        vtctx->transfer_function = NULL;
+    }
+
+    if (vtctx->ycbcr_matrix) {
+        CFRelease(vtctx->ycbcr_matrix);
+        vtctx->ycbcr_matrix = NULL;
+    }
+}
+
 static int vtenc_q_pop(VTEncContext *vtctx, bool wait, CMSampleBufferRef *buf, ExtraSEI **sei)
 {
     BufNode *info;
@@ -419,43 +509,45 @@
 }

 static CMVideoCodecType get_cm_codec_type(AVCodecContext *avctx,
-                                          int64_t profile,
+                                          int profile,
                                           double alpha_quality)
 {
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt == AV_PIX_FMT_VIDEOTOOLBOX ? avctx->sw_pix_fmt : avctx->pix_fmt);
     switch (avctx->codec_id) {
-    case AV_CODEC_ID_H264: return kCMVideoCodecType_H264;
-    case AV_CODEC_ID_HEVC:
-        if (desc && (desc->flags & AV_PIX_FMT_FLAG_ALPHA) && alpha_quality > 0.0) {
-            return kCMVideoCodecType_HEVCWithAlpha;
-        }
-        return kCMVideoCodecType_HEVC;
-    case AV_CODEC_ID_PRORES:
-        switch (profile) {
-        case FF_PROFILE_PRORES_PROXY:
-            return MKBETAG('a','p','c','o'); // kCMVideoCodecType_AppleProRes422Proxy
-        case FF_PROFILE_PRORES_LT:
-            return MKBETAG('a','p','c','s'); // kCMVideoCodecType_AppleProRes422LT
-        case FF_PROFILE_PRORES_STANDARD:
-            return MKBETAG('a','p','c','n'); // kCMVideoCodecType_AppleProRes422
-        case FF_PROFILE_PRORES_HQ:
-            return MKBETAG('a','p','c','h'); // kCMVideoCodecType_AppleProRes422HQ
-        case FF_PROFILE_PRORES_4444:
-            return MKBETAG('a','p','4','h'); // kCMVideoCodecType_AppleProRes4444
-        case FF_PROFILE_PRORES_XQ:
-            return MKBETAG('a','p','4','x'); // kCMVideoCodecType_AppleProRes4444XQ
+        case AV_CODEC_ID_H264: return kCMVideoCodecType_H264;
+        case AV_CODEC_ID_HEVC:
+            if (desc && (desc->flags & AV_PIX_FMT_FLAG_ALPHA) && alpha_quality > 0.0) {
+                return kCMVideoCodecType_HEVCWithAlpha;
+            }
+            return kCMVideoCodecType_HEVC;
+        case AV_CODEC_ID_PRORES:
+            if (desc && (desc->flags & AV_PIX_FMT_FLAG_ALPHA))
+                avctx->bits_per_coded_sample = 32;
+            switch (profile) {
+                case FF_PROFILE_PRORES_PROXY:
+                    return MKBETAG('a','p','c','o'); // kCMVideoCodecType_AppleProRes422Proxy
+                case FF_PROFILE_PRORES_LT:
+                    return MKBETAG('a','p','c','s'); // kCMVideoCodecType_AppleProRes422LT
+                case FF_PROFILE_PRORES_STANDARD:
+                    return MKBETAG('a','p','c','n'); // kCMVideoCodecType_AppleProRes422
+                case FF_PROFILE_PRORES_HQ:
+                    return MKBETAG('a','p','c','h'); // kCMVideoCodecType_AppleProRes422HQ
+                case FF_PROFILE_PRORES_4444:
+                    return MKBETAG('a','p','4','h'); // kCMVideoCodecType_AppleProRes4444
+                case FF_PROFILE_PRORES_XQ:
+                    return MKBETAG('a','p','4','x'); // kCMVideoCodecType_AppleProRes4444XQ

-        default:
-            av_log(avctx, AV_LOG_ERROR, "Unknown profile ID: %"PRId64", using auto\n", profile);
-        case FF_PROFILE_UNKNOWN:
-            if (desc &&
-                ((desc->flags & AV_PIX_FMT_FLAG_ALPHA) ||
-                  desc->log2_chroma_w == 0))
-                return MKBETAG('a','p','4','h'); // kCMVideoCodecType_AppleProRes4444
-            else
-                return MKBETAG('a','p','c','n'); // kCMVideoCodecType_AppleProRes422
-        }
-    default:               return 0;
+                default:
+                    av_log(avctx, AV_LOG_ERROR, "Unknown profile ID: %d, using auto\n", profile);
+                case FF_PROFILE_UNKNOWN:
+                    if (desc &&
+                        ((desc->flags & AV_PIX_FMT_FLAG_ALPHA) ||
+                         desc->log2_chroma_w == 0))
+                        return MKBETAG('a','p','4','h'); // kCMVideoCodecType_AppleProRes4444
+                    else
+                        return MKBETAG('a','p','c','n'); // kCMVideoCodecType_AppleProRes422
+            }
+        default:               return 0;
     }
 }

@@ -711,89 +803,113 @@
                                       CFStringRef    *profile_level_val)
 {
     VTEncContext *vtctx = avctx->priv_data;
-    int64_t profile = vtctx->profile;
+    int profile = vtctx->profile;

-    if (profile == H264_PROF_AUTO && vtctx->level) {
+    if (profile == FF_PROFILE_UNKNOWN && vtctx->level) {
         //Need to pick a profile if level is not auto-selected.
-        profile = vtctx->has_b_frames ? H264_PROF_MAIN : H264_PROF_BASELINE;
+        profile = vtctx->has_b_frames ? FF_PROFILE_H264_MAIN : FF_PROFILE_H264_BASELINE;
     }

     *profile_level_val = NULL;

     switch (profile) {
-        case H264_PROF_AUTO:
+        case FF_PROFILE_UNKNOWN:
             return true;

-        case H264_PROF_BASELINE:
+        case FF_PROFILE_H264_BASELINE:
             switch (vtctx->level) {
                 case  0: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Baseline_AutoLevel; break;
+                             compat_keys.kVTProfileLevel_H264_Baseline_AutoLevel; break;
                 case 13: *profile_level_val = kVTProfileLevel_H264_Baseline_1_3;       break;
                 case 30: *profile_level_val = kVTProfileLevel_H264_Baseline_3_0;       break;
                 case 31: *profile_level_val = kVTProfileLevel_H264_Baseline_3_1;       break;
                 case 32: *profile_level_val = kVTProfileLevel_H264_Baseline_3_2;       break;
                 case 40: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Baseline_4_0;       break;
+                             compat_keys.kVTProfileLevel_H264_Baseline_4_0;       break;
                 case 41: *profile_level_val = kVTProfileLevel_H264_Baseline_4_1;       break;
                 case 42: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Baseline_4_2;       break;
+                             compat_keys.kVTProfileLevel_H264_Baseline_4_2;       break;
                 case 50: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Baseline_5_0;       break;
+                             compat_keys.kVTProfileLevel_H264_Baseline_5_0;       break;
                 case 51: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Baseline_5_1;       break;
+                             compat_keys.kVTProfileLevel_H264_Baseline_5_1;       break;
                 case 52: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Baseline_5_2;       break;
+                             compat_keys.kVTProfileLevel_H264_Baseline_5_2;       break;
             }
             break;

-        case H264_PROF_MAIN:
+        case FF_PROFILE_H264_CONSTRAINED_BASELINE:
+            *profile_level_val =  compat_keys.kVTProfileLevel_H264_ConstrainedBaseline_AutoLevel;
+
+            if (vtctx->level != 0) {
+                av_log(avctx,
+                       AV_LOG_WARNING,
+                       "Level is auto-selected when constrained-baseline "
+                       "profile is used. The output may be encoded with a "
+                       "different level.\n");
+            }
+            break;
+
+        case FF_PROFILE_H264_MAIN:
             switch (vtctx->level) {
                 case  0: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Main_AutoLevel; break;
+                             compat_keys.kVTProfileLevel_H264_Main_AutoLevel; break;
                 case 30: *profile_level_val = kVTProfileLevel_H264_Main_3_0;       break;
                 case 31: *profile_level_val = kVTProfileLevel_H264_Main_3_1;       break;
                 case 32: *profile_level_val = kVTProfileLevel_H264_Main_3_2;       break;
                 case 40: *profile_level_val = kVTProfileLevel_H264_Main_4_0;       break;
                 case 41: *profile_level_val = kVTProfileLevel_H264_Main_4_1;       break;
                 case 42: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Main_4_2;       break;
+                             compat_keys.kVTProfileLevel_H264_Main_4_2;       break;
                 case 50: *profile_level_val = kVTProfileLevel_H264_Main_5_0;       break;
                 case 51: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Main_5_1;       break;
+                             compat_keys.kVTProfileLevel_H264_Main_5_1;       break;
                 case 52: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Main_5_2;       break;
+                             compat_keys.kVTProfileLevel_H264_Main_5_2;       break;
             }
             break;

-        case H264_PROF_HIGH:
+        case H264_PROFILE_CONSTRAINED_HIGH:
+            *profile_level_val =  compat_keys.kVTProfileLevel_H264_ConstrainedHigh_AutoLevel;
+
+            if (vtctx->level != 0) {
+                av_log(avctx,
+                       AV_LOG_WARNING,
+                       "Level is auto-selected when constrained-high profile "
+                       "is used. The output may be encoded with a different "
+                       "level.\n");
+            }
+            break;
+
+        case FF_PROFILE_H264_HIGH:
             switch (vtctx->level) {
                 case  0: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_High_AutoLevel; break;
+                             compat_keys.kVTProfileLevel_H264_High_AutoLevel; break;
                 case 30: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_High_3_0;       break;
+                             compat_keys.kVTProfileLevel_H264_High_3_0;       break;
                 case 31: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_High_3_1;       break;
+                             compat_keys.kVTProfileLevel_H264_High_3_1;       break;
                 case 32: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_High_3_2;       break;
+                             compat_keys.kVTProfileLevel_H264_High_3_2;       break;
                 case 40: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_High_4_0;       break;
+                             compat_keys.kVTProfileLevel_H264_High_4_0;       break;
                 case 41: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_High_4_1;       break;
+                             compat_keys.kVTProfileLevel_H264_High_4_1;       break;
                 case 42: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_High_4_2;       break;
+                             compat_keys.kVTProfileLevel_H264_High_4_2;       break;
                 case 50: *profile_level_val = kVTProfileLevel_H264_High_5_0;       break;
                 case 51: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_High_5_1;       break;
+                             compat_keys.kVTProfileLevel_H264_High_5_1;       break;
                 case 52: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_High_5_2;       break;
+                             compat_keys.kVTProfileLevel_H264_High_5_2;       break;
             }
             break;
-        case H264_PROF_EXTENDED:
+        case FF_PROFILE_H264_EXTENDED:
             switch (vtctx->level) {
                 case  0: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Extended_AutoLevel; break;
+                             compat_keys.kVTProfileLevel_H264_Extended_AutoLevel; break;
                 case 50: *profile_level_val =
-                                  compat_keys.kVTProfileLevel_H264_Extended_5_0;       break;
+                             compat_keys.kVTProfileLevel_H264_Extended_5_0;       break;
             }
             break;
     }
@@ -816,18 +932,36 @@
                                       CFStringRef    *profile_level_val)
 {
     VTEncContext *vtctx = avctx->priv_data;
-    int64_t profile = vtctx->profile;
+    int profile = vtctx->profile;
+    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(
+        avctx->pix_fmt == AV_PIX_FMT_VIDEOTOOLBOX ? avctx->sw_pix_fmt
+                                                  : avctx->pix_fmt);
+    int bit_depth = desc ? desc->comp[0].depth : 0;

     *profile_level_val = NULL;

     switch (profile) {
-        case HEVC_PROF_AUTO:
+        case FF_PROFILE_UNKNOWN:
+            // Set profile automatically if user don't specify
+            if (bit_depth == 10) {
+                *profile_level_val =
+                    compat_keys.kVTProfileLevel_HEVC_Main10_AutoLevel;
+                break;
+            }
             return true;
-        case HEVC_PROF_MAIN:
+        case FF_PROFILE_HEVC_MAIN:
+            if (bit_depth > 0 && bit_depth != 8)
+                av_log(avctx, AV_LOG_WARNING,
+                       "main profile with %d bit input\n", bit_depth);
             *profile_level_val =
                 compat_keys.kVTProfileLevel_HEVC_Main_AutoLevel;
             break;
-        case HEVC_PROF_MAIN10:
+        case FF_PROFILE_HEVC_MAIN_10:
+            if (bit_depth > 0 && bit_depth != 10) {
+                av_log(avctx, AV_LOG_ERROR,
+                       "Invalid main10 profile with %d bit input\n", bit_depth);
+                return false;
+            }
             *profile_level_val =
                 compat_keys.kVTProfileLevel_HEVC_Main10_AutoLevel;
             break;
@@ -858,9 +992,9 @@

     range_name = av_color_range_name(range);
     av_log(avctx, AV_LOG_ERROR,
-        "Could not get pixel format for color format '%s' range '%s'.\n",
-        av_get_pix_fmt_name(fmt),
-        range_name ? range_name : "Unknown");
+           "Could not get pixel format for color format '%s' range '%s'.\n",
+           av_get_pix_fmt_name(fmt),
+           range_name ? range_name : "Unknown");

     return AVERROR(EINVAL);
 }
@@ -903,10 +1037,10 @@
     if (status) return status;

     pixel_buffer_info = CFDictionaryCreateMutable(
-                            kCFAllocatorDefault,
-                            20,
-                            &kCFCopyStringDictionaryKeyCallBacks,
-                            &kCFTypeDictionaryValueCallBacks);
+        kCFAllocatorDefault,
+        20,
+        &kCFCopyStringDictionaryKeyCallBacks,
+        &kCFTypeDictionaryValueCallBacks);

     if (!pixel_buffer_info) goto pbinfo_nomem;

@@ -945,7 +1079,7 @@
     *dict = pixel_buffer_info;
     return 0;

-pbinfo_nomem:
+    pbinfo_nomem:
     vt_release_num(&cv_color_format_num);
     vt_release_num(&width_num);
     vt_release_num(&height_num);
@@ -954,132 +1088,20 @@
     return AVERROR(ENOMEM);
 }

-static int get_cv_color_primaries(AVCodecContext *avctx,
-                                  CFStringRef *primaries)
-{
-    enum AVColorPrimaries pri = avctx->color_primaries;
-    switch (pri) {
-        case AVCOL_PRI_UNSPECIFIED:
-            *primaries = NULL;
-            break;
-
-        case AVCOL_PRI_BT470BG:
-            *primaries = kCVImageBufferColorPrimaries_EBU_3213;
-            break;
-
-        case AVCOL_PRI_SMPTE170M:
-            *primaries = kCVImageBufferColorPrimaries_SMPTE_C;
-            break;
-
-        case AVCOL_PRI_BT709:
-            *primaries = kCVImageBufferColorPrimaries_ITU_R_709_2;
-            break;
-
-        case AVCOL_PRI_BT2020:
-            *primaries = compat_keys.kCVImageBufferColorPrimaries_ITU_R_2020;
-            break;
-
-        default:
-            av_log(avctx, AV_LOG_ERROR, "Color primaries %s is not supported.\n", av_color_primaries_name(pri));
-            *primaries = NULL;
-            return -1;
-    }
-
-    return 0;
-}
-
-static int get_cv_transfer_function(AVCodecContext *avctx,
-                                    CFStringRef *transfer_fnc,
-                                    CFNumberRef *gamma_level)
+static int get_cv_gamma(AVCodecContext *avctx,
+                        CFNumberRef *gamma_level)
 {
     enum AVColorTransferCharacteristic trc = avctx->color_trc;
-    Float32 gamma;
+    Float32 gamma = 0;
     *gamma_level = NULL;

-    switch (trc) {
-        case AVCOL_TRC_UNSPECIFIED:
-            *transfer_fnc = NULL;
-            break;
-
-        case AVCOL_TRC_BT709:
-            *transfer_fnc = kCVImageBufferTransferFunction_ITU_R_709_2;
-            break;
-
-        case AVCOL_TRC_SMPTE240M:
-            *transfer_fnc = kCVImageBufferTransferFunction_SMPTE_240M_1995;
-            break;
-
-#if HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ
-        case AVCOL_TRC_SMPTE2084:
-            *transfer_fnc = kCVImageBufferTransferFunction_SMPTE_ST_2084_PQ;
-            break;
-#endif
-#if HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR
-        case AVCOL_TRC_LINEAR:
-            *transfer_fnc = kCVImageBufferTransferFunction_Linear;
-            break;
-#endif
-#if HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG
-        case AVCOL_TRC_ARIB_STD_B67:
-            *transfer_fnc = kCVImageBufferTransferFunction_ITU_R_2100_HLG;
-            break;
-#endif
-
-        case AVCOL_TRC_GAMMA22:
-            gamma = 2.2;
-            *transfer_fnc = kCVImageBufferTransferFunction_UseGamma;
-            *gamma_level = CFNumberCreate(NULL, kCFNumberFloat32Type, &gamma);
-            break;
-
-        case AVCOL_TRC_GAMMA28:
-            gamma = 2.8;
-            *transfer_fnc = kCVImageBufferTransferFunction_UseGamma;
-            *gamma_level = CFNumberCreate(NULL, kCFNumberFloat32Type, &gamma);
-            break;
-
-        case AVCOL_TRC_BT2020_10:
-        case AVCOL_TRC_BT2020_12:
-            *transfer_fnc = compat_keys.kCVImageBufferTransferFunction_ITU_R_2020;
-            break;
-
-        default:
-            *transfer_fnc = NULL;
-            av_log(avctx, AV_LOG_ERROR, "Transfer function %s is not supported.\n", av_color_transfer_name(trc));
-            return -1;
-    }
-
-    return 0;
-}
-
-static int get_cv_ycbcr_matrix(AVCodecContext *avctx, CFStringRef *matrix) {
-    switch(avctx->colorspace) {
-        case AVCOL_SPC_BT709:
-            *matrix = kCVImageBufferYCbCrMatrix_ITU_R_709_2;
-            break;
-
-        case AVCOL_SPC_UNSPECIFIED:
-        case AVCOL_SPC_RGB:
-            *matrix = NULL;
-            break;
-
-        case AVCOL_SPC_BT470BG:
-        case AVCOL_SPC_SMPTE170M:
-            *matrix = kCVImageBufferYCbCrMatrix_ITU_R_601_4;
-            break;
-
-        case AVCOL_SPC_SMPTE240M:
-            *matrix = kCVImageBufferYCbCrMatrix_SMPTE_240M_1995;
-            break;
-
-        case AVCOL_SPC_BT2020_NCL:
-            *matrix = compat_keys.kCVImageBufferYCbCrMatrix_ITU_R_2020;
-            break;
-
-        default:
-            av_log(avctx, AV_LOG_ERROR, "Color space %s is not supported.\n", av_color_space_name(avctx->colorspace));
-            return -1;
-    }
-
+    if (trc == AVCOL_TRC_GAMMA22)
+        gamma = 2.2;
+    else if (trc == AVCOL_TRC_GAMMA28)
+        gamma = 2.8;
+
+    if (gamma != 0)
+        *gamma_level = CFNumberCreate(NULL, kCFNumberFloat32Type, &gamma);
     return 0;
 }

@@ -1089,6 +1111,47 @@
     return !TARGET_OS_IPHONE && TARGET_CPU_ARM64;
 }

+static void set_encoder_property_or_log(AVCodecContext *avctx,
+                                        CFStringRef key,
+                                        const char *print_option_name,
+                                        CFTypeRef value) {
+    int status;
+    VTEncContext *vtctx = avctx->priv_data;
+
+    status = VTSessionSetProperty(vtctx->session, key, value);
+    if (status == kVTPropertyNotSupportedErr) {
+        av_log(avctx,
+               AV_LOG_INFO,
+               "This device does not support the %s option. Value ignored.\n",
+               print_option_name);
+    } else if (status != 0) {
+        av_log(avctx,
+               AV_LOG_ERROR,
+               "Error setting %s: Error %d\n",
+               print_option_name,
+               status);
+    }
+}
+
+static int set_encoder_int_property_or_log(AVCodecContext* avctx,
+                                           CFStringRef key,
+                                           const char* print_option_name,
+                                           int value) {
+    CFNumberRef value_cfnum = CFNumberCreate(kCFAllocatorDefault,
+                                             kCFNumberIntType,
+                                             &value);
+
+    if (value_cfnum == NULL) {
+        return AVERROR(ENOMEM);
+    }
+
+    set_encoder_property_or_log(avctx, key, print_option_name, value_cfnum);
+
+    CFRelease(value_cfnum);
+
+    return 0;
+}
+
 static int vtenc_create_encoder(AVCodecContext   *avctx,
                                 CMVideoCodecType codec_type,
                                 CFStringRef      profile_level,
@@ -1134,6 +1197,26 @@
         return AVERROR_EXTERNAL;
     }

+#if defined (MAC_OS_X_VERSION_10_13) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_13)
+    if (__builtin_available(macOS 10.13, *)) {
+        status = VTCopySupportedPropertyDictionaryForEncoder(avctx->width,
+                                                             avctx->height,
+                                                             codec_type,
+                                                             enc_info,
+                                                             NULL,
+                                                             &vtctx->supported_props);
+
+        if (status != noErr) {
+            av_log(avctx, AV_LOG_ERROR,"Error retrieving the supported property dictionary err=%"PRId64"\n", (int64_t)status);
+            return AVERROR_EXTERNAL;
+        }
+    }
+#endif
+
+    status = vt_dump_encoder(avctx);
+    if (status < 0)
+        return status;
+
     if (avctx->flags & AV_CODEC_FLAG_QSCALE && !vtenc_qscale_enabled()) {
         av_log(avctx, AV_LOG_ERROR, "Error: -q:v qscale not available for encoder. Use -b:v bitrate instead.\n");
         return AVERROR_EXTERNAL;
@@ -1188,7 +1271,7 @@
     }

     if ((vtctx->codec_id == AV_CODEC_ID_H264 || vtctx->codec_id == AV_CODEC_ID_HEVC)
-            && max_rate > 0) {
+        && max_rate > 0) {
         bytes_per_second_value = max_rate >> 3;
         bytes_per_second = CFNumberCreate(kCFAllocatorDefault,
                                           kCFNumberSInt64Type,
@@ -1245,6 +1328,13 @@
                                           compat_keys.kVTCompressionPropertyKey_TargetQualityForAlpha,
                                           alpha_quality_num);
             CFRelease(alpha_quality_num);
+
+            if (status) {
+                av_log(avctx,
+                       AV_LOG_ERROR,
+                       "Error setting alpha quality: %d\n",
+                       status);
+            }
         }
     }

@@ -1307,7 +1397,7 @@
         AVRational *avpar = &avctx->sample_aspect_ratio;

         av_reduce(&avpar->num, &avpar->den,
-                   avpar->num,  avpar->den,
+                  avpar->num,  avpar->den,
                   0xFFFFFFFF);

         num = CFNumberCreate(kCFAllocatorDefault,
@@ -1419,8 +1509,8 @@

     if (vtctx->entropy != VT_ENTROPY_NOT_SET) {
         CFStringRef entropy = vtctx->entropy == VT_CABAC ?
-                                compat_keys.kVTH264EntropyMode_CABAC:
-                                compat_keys.kVTH264EntropyMode_CAVLC;
+                              compat_keys.kVTH264EntropyMode_CABAC:
+                              compat_keys.kVTH264EntropyMode_CAVLC;

         status = VTSessionSetProperty(vtctx->session,
                                       compat_keys.kVTCompressionPropertyKey_H264EntropyMode,
@@ -1441,6 +1531,64 @@
         }
     }

+    if ((avctx->flags & AV_CODEC_FLAG_CLOSED_GOP) != 0) {
+        set_encoder_property_or_log(avctx,
+                                    compat_keys.kVTCompressionPropertyKey_AllowOpenGOP,
+                                    "AllowOpenGop",
+                                    kCFBooleanFalse);
+    }
+
+    if (avctx->qmin >= 0) {
+        status = set_encoder_int_property_or_log(avctx,
+                                                 compat_keys.kVTCompressionPropertyKey_MinAllowedFrameQP,
+                                                 "qmin",
+                                                 avctx->qmin);
+
+        if (status != 0) {
+            return status;
+        }
+    }
+
+    if (avctx->qmax >= 0) {
+        status = set_encoder_int_property_or_log(avctx,
+                                                 compat_keys.kVTCompressionPropertyKey_MaxAllowedFrameQP,
+                                                 "qmax",
+                                                 avctx->qmax);
+
+        if (status != 0) {
+            return status;
+        }
+    }
+
+    if (vtctx->max_slice_bytes >= 0 && avctx->codec_id == AV_CODEC_ID_H264) {
+        status = set_encoder_int_property_or_log(avctx,
+                                                 kVTCompressionPropertyKey_MaxH264SliceBytes,
+                                                 "max_slice_bytes",
+                                                 vtctx->max_slice_bytes);
+
+        if (status != 0) {
+            return status;
+        }
+    }
+
+    if (vtctx->power_efficient >= 0) {
+        set_encoder_property_or_log(avctx,
+                                    compat_keys.kVTCompressionPropertyKey_MaximizePowerEfficiency,
+                                    "power_efficient",
+                                    vtctx->power_efficient ? kCFBooleanTrue : kCFBooleanFalse);
+    }
+
+    if (vtctx->max_ref_frames > 0) {
+        status = set_encoder_int_property_or_log(avctx,
+                                                 compat_keys.kVTCompressionPropertyKey_ReferenceBufferCount,
+                                                 "max_ref_frames",
+                                                 vtctx->max_ref_frames);
+
+        if (status != 0) {
+            return status;
+        }
+    }
+
     status = VTCompressionSessionPrepareToEncodeFrames(vtctx->session);
     if (status) {
         av_log(avctx, AV_LOG_ERROR, "Error: cannot prepare encoder: %d\n", status);
@@ -1480,12 +1628,12 @@
         vtctx->get_param_set_func = CMVideoFormatDescriptionGetH264ParameterSetAtIndex;

         vtctx->has_b_frames = avctx->max_b_frames > 0;
-        if(vtctx->has_b_frames && vtctx->profile == H264_PROF_BASELINE){
+        if(vtctx->has_b_frames && (0xFF & vtctx->profile) == FF_PROFILE_H264_BASELINE){
             av_log(avctx, AV_LOG_WARNING, "Cannot use B-frames with baseline profile. Output will not contain B-frames.\n");
             vtctx->has_b_frames = 0;
         }

-        if (vtctx->entropy == VT_CABAC && vtctx->profile == H264_PROF_BASELINE) {
+        if (vtctx->entropy == VT_CABAC && (0xFF & vtctx->profile) == FF_PROFILE_H264_BASELINE) {
             av_log(avctx, AV_LOG_WARNING, "CABAC entropy requires 'main' or 'high' profile, but baseline was requested. Encode will not use CABAC entropy.\n");
             vtctx->entropy = VT_ENTROPY_NOT_SET;
         }
@@ -1526,6 +1674,13 @@
     }
 #endif

+    // low-latency mode: eliminate frame reordering, follow a one-in-one-out encoding mode
+    if ((avctx->flags & AV_CODEC_FLAG_LOW_DELAY) && avctx->codec_id == AV_CODEC_ID_H264) {
+        CFDictionarySetValue(enc_info,
+                             compat_keys.kVTVideoEncoderSpecification_EnableLowLatencyRateControl,
+                             kCFBooleanTrue);
+    }
+
     if (avctx->pix_fmt != AV_PIX_FMT_VIDEOTOOLBOX) {
         status = create_cv_pixel_buffer_info(avctx, &pixel_buffer_info);
         if (status)
@@ -1534,9 +1689,10 @@

     vtctx->dts_delta = vtctx->has_b_frames ? -1 : 0;

-    get_cv_transfer_function(avctx, &vtctx->transfer_function, &gamma_level);
-    get_cv_ycbcr_matrix(avctx, &vtctx->ycbcr_matrix);
-    get_cv_color_primaries(avctx, &vtctx->color_primaries);
+    get_cv_gamma(avctx, &gamma_level);
+    vtctx->transfer_function = av_map_videotoolbox_color_trc_from_av(avctx->color_trc);
+    vtctx->ycbcr_matrix = av_map_videotoolbox_color_matrix_from_av(avctx->colorspace);
+    vtctx->color_primaries = av_map_videotoolbox_color_primaries_from_av(avctx->color_primaries);


     if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
@@ -1559,7 +1715,7 @@
                                   vtctx->constant_bit_rate,
                                   &vtctx->session);

-init_cleanup:
+    init_cleanup:
     if (gamma_level)
         CFRelease(gamma_level);

@@ -1582,7 +1738,9 @@
     pthread_mutex_init(&vtctx->lock, NULL);
     pthread_cond_init(&vtctx->cv_sample_sent, NULL);

-    vtctx->session = NULL;
+    // It can happen when user set avctx->profile directly.
+    if (vtctx->profile == FF_PROFILE_UNKNOWN)
+        vtctx->profile = avctx->profile;
     status = vtenc_configure_encoder(avctx);
     if (status) return status;

@@ -1650,8 +1808,8 @@
 {
     int nal_type;
     size_t sei_payload_size = 0;
+    uint8_t *nal_start = nal_data;
     *sei_end = NULL;
-    uint8_t *nal_start = nal_data;

     if (!nal_size)
         return 0;
@@ -2041,7 +2199,7 @@
                 return AVERROR_EXTERNAL;
             }

-            int status = get_params_size(avctx, vid_fmt, &header_size);
+            status = get_params_size(avctx, vid_fmt, &header_size);
             if (status) return status;
         }

@@ -2146,7 +2304,7 @@
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
     VTEncContext *vtctx = avctx->priv_data;
     int av_format       = frame->format;
-    int av_color_range  = frame->color_range;
+    int av_color_range  = avctx->color_range;
     int i;
     int range_guessed;
     int status;
@@ -2229,8 +2387,8 @@
             if (i == plane_count) {
                 CVPixelBufferUnlockBaseAddress(cv_img, 0);
                 av_log(avctx,
-                    AV_LOG_ERROR,
-                    "Error: different number of planes in AVFrame and CVPixelBuffer.\n"
+                       AV_LOG_ERROR,
+                       "Error: different number of planes in AVFrame and CVPixelBuffer.\n"
                 );

                 return AVERROR_EXTERNAL;
@@ -2256,8 +2414,8 @@
         if (frame->data[1]) {
             CVPixelBufferUnlockBaseAddress(cv_img, 0);
             av_log(avctx,
-                AV_LOG_ERROR,
-                "Error: different number of planes in AVFrame and non-planar CVPixelBuffer.\n"
+                   AV_LOG_ERROR,
+                   "Error: different number of planes in AVFrame and non-planar CVPixelBuffer.\n"
             );

             return AVERROR_EXTERNAL;
@@ -2351,8 +2509,8 @@

         vtstatus = VTCompressionSessionPrepareToEncodeFrames(vtctx->session);
         if (vtstatus == kVTInvalidSessionErr) {
-            CFRelease(vtctx->session);
-            vtctx->session = NULL;
+            vtenc_reset(vtctx);
+
             status = vtenc_configure_encoder(avctx);
             if (status == 0)
                 pix_buf_pool = VTCompressionSessionGetPixelBufferPool(vtctx->session);
@@ -2363,7 +2521,7 @@
         }
         else
             av_log(avctx, AV_LOG_WARNING, "VT session restarted because of a "
-                   "kVTInvalidSessionErr error.\n");
+                                          "kVTInvalidSessionErr error.\n");
     }

     status = CVPixelBufferPoolCreatePixelBuffer(NULL,
@@ -2522,7 +2680,7 @@
     *got_packet = 1;
     return 0;

-end_nopkt:
+    end_nopkt:
     av_packet_unref(pkt);
     return status;
 }
@@ -2606,12 +2764,9 @@



-pe_cleanup:
+    pe_cleanup:
     CVPixelBufferRelease(pix_buf);
-    if(vtctx->session)
-        CFRelease(vtctx->session);
-
-    vtctx->session = NULL;
+    vtenc_reset(vtctx);
     vtctx->frame_ct_out = 0;

     av_assert0(status != 0 || (avctx->extradata && avctx->extradata_size > 0));
@@ -2634,23 +2789,8 @@
     clear_frame_queue(vtctx);
     pthread_cond_destroy(&vtctx->cv_sample_sent);
     pthread_mutex_destroy(&vtctx->lock);
-    CFRelease(vtctx->session);
-    vtctx->session = NULL;
-
-    if (vtctx->color_primaries) {
-        CFRelease(vtctx->color_primaries);
-        vtctx->color_primaries = NULL;
-    }

-    if (vtctx->transfer_function) {
-        CFRelease(vtctx->transfer_function);
-        vtctx->transfer_function = NULL;
-    }
-
-    if (vtctx->ycbcr_matrix) {
-        CFRelease(vtctx->ycbcr_matrix);
-        vtctx->ycbcr_matrix = NULL;
-    }
+    vtenc_reset(vtctx);

     return 0;
 }
@@ -2718,37 +2858,49 @@
         OFFSET(frames_after), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VE }, \
     { "prio_speed", "prioritize encoding speed", OFFSET(prio_speed), AV_OPT_TYPE_BOOL, \
         { .i64 = -1 }, -1, 1, VE }, \
+    { "power_efficient", "Set to 1 to enable more power-efficient encoding if supported.", \
+        OFFSET(power_efficient), AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 1, VE }, \
+    { "max_ref_frames", \
+        "Sets the maximum number of reference frames. This only has an effect when the value is less than the maximum allowed by the profile/level.", \
+        OFFSET(max_ref_frames), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VE },
+
+static const AVCodecHWConfigInternal *const vt_encode_hw_configs[] = {
+    HW_CONFIG_ENCODER_FRAMES(VIDEOTOOLBOX, VIDEOTOOLBOX),
+    NULL,
+};

 #define OFFSET(x) offsetof(VTEncContext, x)
 static const AVOption h264_options[] = {
-    { "profile", "Profile", OFFSET(profile), AV_OPT_TYPE_INT64, { .i64 = H264_PROF_AUTO }, H264_PROF_AUTO, H264_PROF_COUNT, VE, "profile" },
-    { "baseline", "Baseline Profile", 0, AV_OPT_TYPE_CONST, { .i64 = H264_PROF_BASELINE }, INT_MIN, INT_MAX, VE, "profile" },
-    { "main",     "Main Profile",     0, AV_OPT_TYPE_CONST, { .i64 = H264_PROF_MAIN     }, INT_MIN, INT_MAX, VE, "profile" },
-    { "high",     "High Profile",     0, AV_OPT_TYPE_CONST, { .i64 = H264_PROF_HIGH     }, INT_MIN, INT_MAX, VE, "profile" },
-    { "extended", "Extend Profile",   0, AV_OPT_TYPE_CONST, { .i64 = H264_PROF_EXTENDED }, INT_MIN, INT_MAX, VE, "profile" },
+    { "profile", "Profile", OFFSET(profile), AV_OPT_TYPE_INT, { .i64 = FF_PROFILE_UNKNOWN }, FF_PROFILE_UNKNOWN, INT_MAX, VE, .unit = "profile" },
+    { "baseline",             "Baseline Profile",             0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_BASELINE             }, INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "constrained_baseline", "Constrained Baseline Profile", 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_CONSTRAINED_BASELINE }, INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "main",                 "Main Profile",                 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_MAIN                 }, INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "high",                 "High Profile",                 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_HIGH                 }, INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "constrained_high",     "Constrained High Profile",     0, AV_OPT_TYPE_CONST, { .i64 = H264_PROFILE_CONSTRAINED_HIGH        }, INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "extended",             "Extend Profile",               0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_EXTENDED             }, INT_MIN, INT_MAX, VE, .unit = "profile" },

-    { "level", "Level", OFFSET(level), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 52, VE, "level" },
-    { "1.3", "Level 1.3, only available with Baseline Profile", 0, AV_OPT_TYPE_CONST, { .i64 = 13 }, INT_MIN, INT_MAX, VE, "level" },
-    { "3.0", "Level 3.0", 0, AV_OPT_TYPE_CONST, { .i64 = 30 }, INT_MIN, INT_MAX, VE, "level" },
-    { "3.1", "Level 3.1", 0, AV_OPT_TYPE_CONST, { .i64 = 31 }, INT_MIN, INT_MAX, VE, "level" },
-    { "3.2", "Level 3.2", 0, AV_OPT_TYPE_CONST, { .i64 = 32 }, INT_MIN, INT_MAX, VE, "level" },
-    { "4.0", "Level 4.0", 0, AV_OPT_TYPE_CONST, { .i64 = 40 }, INT_MIN, INT_MAX, VE, "level" },
-    { "4.1", "Level 4.1", 0, AV_OPT_TYPE_CONST, { .i64 = 41 }, INT_MIN, INT_MAX, VE, "level" },
-    { "4.2", "Level 4.2", 0, AV_OPT_TYPE_CONST, { .i64 = 42 }, INT_MIN, INT_MAX, VE, "level" },
-    { "5.0", "Level 5.0", 0, AV_OPT_TYPE_CONST, { .i64 = 50 }, INT_MIN, INT_MAX, VE, "level" },
-    { "5.1", "Level 5.1", 0, AV_OPT_TYPE_CONST, { .i64 = 51 }, INT_MIN, INT_MAX, VE, "level" },
-    { "5.2", "Level 5.2", 0, AV_OPT_TYPE_CONST, { .i64 = 52 }, INT_MIN, INT_MAX, VE, "level" },
+    { "level", "Level", OFFSET(level), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 52, VE, .unit = "level" },
+    { "1.3", "Level 1.3, only available with Baseline Profile", 0, AV_OPT_TYPE_CONST, { .i64 = 13 }, INT_MIN, INT_MAX, VE, .unit = "level" },
+    { "3.0", "Level 3.0", 0, AV_OPT_TYPE_CONST, { .i64 = 30 }, INT_MIN, INT_MAX, VE, .unit = "level" },
+    { "3.1", "Level 3.1", 0, AV_OPT_TYPE_CONST, { .i64 = 31 }, INT_MIN, INT_MAX, VE, .unit = "level" },
+    { "3.2", "Level 3.2", 0, AV_OPT_TYPE_CONST, { .i64 = 32 }, INT_MIN, INT_MAX, VE, .unit = "level" },
+    { "4.0", "Level 4.0", 0, AV_OPT_TYPE_CONST, { .i64 = 40 }, INT_MIN, INT_MAX, VE, .unit = "level" },
+    { "4.1", "Level 4.1", 0, AV_OPT_TYPE_CONST, { .i64 = 41 }, INT_MIN, INT_MAX, VE, .unit = "level" },
+    { "4.2", "Level 4.2", 0, AV_OPT_TYPE_CONST, { .i64 = 42 }, INT_MIN, INT_MAX, VE, .unit = "level" },
+    { "5.0", "Level 5.0", 0, AV_OPT_TYPE_CONST, { .i64 = 50 }, INT_MIN, INT_MAX, VE, .unit = "level" },
+    { "5.1", "Level 5.1", 0, AV_OPT_TYPE_CONST, { .i64 = 51 }, INT_MIN, INT_MAX, VE, .unit = "level" },
+    { "5.2", "Level 5.2", 0, AV_OPT_TYPE_CONST, { .i64 = 52 }, INT_MIN, INT_MAX, VE, .unit = "level" },

-    { "coder", "Entropy coding", OFFSET(entropy), AV_OPT_TYPE_INT, { .i64 = VT_ENTROPY_NOT_SET }, VT_ENTROPY_NOT_SET, VT_CABAC, VE, "coder" },
-    { "cavlc", "CAVLC entropy coding", 0, AV_OPT_TYPE_CONST, { .i64 = VT_CAVLC }, INT_MIN, INT_MAX, VE, "coder" },
-    { "vlc",   "CAVLC entropy coding", 0, AV_OPT_TYPE_CONST, { .i64 = VT_CAVLC }, INT_MIN, INT_MAX, VE, "coder" },
-    { "cabac", "CABAC entropy coding", 0, AV_OPT_TYPE_CONST, { .i64 = VT_CABAC }, INT_MIN, INT_MAX, VE, "coder" },
-    { "ac",    "CABAC entropy coding", 0, AV_OPT_TYPE_CONST, { .i64 = VT_CABAC }, INT_MIN, INT_MAX, VE, "coder" },
+    { "coder", "Entropy coding", OFFSET(entropy), AV_OPT_TYPE_INT, { .i64 = VT_ENTROPY_NOT_SET }, VT_ENTROPY_NOT_SET, VT_CABAC, VE, .unit = "coder" },
+    { "cavlc", "CAVLC entropy coding", 0, AV_OPT_TYPE_CONST, { .i64 = VT_CAVLC }, INT_MIN, INT_MAX, VE, .unit = "coder" },
+    { "vlc",   "CAVLC entropy coding", 0, AV_OPT_TYPE_CONST, { .i64 = VT_CAVLC }, INT_MIN, INT_MAX, VE, .unit = "coder" },
+    { "cabac", "CABAC entropy coding", 0, AV_OPT_TYPE_CONST, { .i64 = VT_CABAC }, INT_MIN, INT_MAX, VE, .unit = "coder" },
+    { "ac",    "CABAC entropy coding", 0, AV_OPT_TYPE_CONST, { .i64 = VT_CABAC }, INT_MIN, INT_MAX, VE, .unit = "coder" },

     { "a53cc", "Use A53 Closed Captions (if available)", OFFSET(a53_cc), AV_OPT_TYPE_BOOL, {.i64 = 1}, 0, 1, VE },

     { "constant_bit_rate", "Require constant bit rate (macOS 13 or newer)", OFFSET(constant_bit_rate), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VE },
-
+    { "max_slice_bytes", "Set the maximum number of bytes in an H.264 slice.", OFFSET(max_slice_bytes), AV_OPT_TYPE_INT, { .i64 = -1 }, -1, INT_MAX, VE },
     COMMON_OPTIONS
     { NULL },
 };
@@ -2773,12 +2925,13 @@
     .close            = vtenc_close,
     .p.priv_class     = &h264_videotoolbox_class,
     .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
+    .hw_configs       = vt_encode_hw_configs,
 };

 static const AVOption hevc_options[] = {
-    { "profile", "Profile", OFFSET(profile), AV_OPT_TYPE_INT64, { .i64 = HEVC_PROF_AUTO }, HEVC_PROF_AUTO, HEVC_PROF_COUNT, VE, "profile" },
-    { "main",     "Main Profile",     0, AV_OPT_TYPE_CONST, { .i64 = HEVC_PROF_MAIN   }, INT_MIN, INT_MAX, VE, "profile" },
-    { "main10",   "Main10 Profile",   0, AV_OPT_TYPE_CONST, { .i64 = HEVC_PROF_MAIN10 }, INT_MIN, INT_MAX, VE, "profile" },
+    { "profile", "Profile", OFFSET(profile), AV_OPT_TYPE_INT, { .i64 = FF_PROFILE_UNKNOWN }, FF_PROFILE_UNKNOWN, INT_MAX, VE, .unit = "profile" },
+    { "main",     "Main Profile",     0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_HEVC_MAIN    }, INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "main10",   "Main10 Profile",   0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_HEVC_MAIN_10 }, INT_MIN, INT_MAX, VE, .unit = "profile" },

     { "alpha_quality", "Compression quality for the alpha channel", OFFSET(alpha_quality), AV_OPT_TYPE_DOUBLE, { .dbl = 0.0 }, 0.0, 1.0, VE },

@@ -2810,17 +2963,18 @@
     .p.priv_class     = &hevc_videotoolbox_class,
     .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
     .p.wrapper_name   = "videotoolbox",
+    .hw_configs       = vt_encode_hw_configs,
 };

 static const AVOption prores_options[] = {
-    { "profile", "Profile", OFFSET(profile), AV_OPT_TYPE_INT64, { .i64 = FF_PROFILE_UNKNOWN }, FF_PROFILE_UNKNOWN, FF_PROFILE_PRORES_XQ, VE, "profile" },
-    { "auto",     "Automatically determine based on input format", 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_UNKNOWN },            INT_MIN, INT_MAX, VE, "profile" },
-    { "proxy",    "ProRes 422 Proxy",                              0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_PROXY },       INT_MIN, INT_MAX, VE, "profile" },
-    { "lt",       "ProRes 422 LT",                                 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_LT },          INT_MIN, INT_MAX, VE, "profile" },
-    { "standard", "ProRes 422",                                    0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_STANDARD },    INT_MIN, INT_MAX, VE, "profile" },
-    { "hq",       "ProRes 422 HQ",                                 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_HQ },          INT_MIN, INT_MAX, VE, "profile" },
-    { "4444",     "ProRes 4444",                                   0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_4444 },        INT_MIN, INT_MAX, VE, "profile" },
-    { "xq",       "ProRes 4444 XQ",                                0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_XQ },          INT_MIN, INT_MAX, VE, "profile" },
+    { "profile", "Profile", OFFSET(profile), AV_OPT_TYPE_INT, { .i64 = FF_PROFILE_UNKNOWN }, FF_PROFILE_UNKNOWN, FF_PROFILE_PRORES_XQ, VE, .unit = "profile" },
+    { "auto",     "Automatically determine based on input format", 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_UNKNOWN },            INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "proxy",    "ProRes 422 Proxy",                              0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_PROXY },       INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "lt",       "ProRes 422 LT",                                 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_LT },          INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "standard", "ProRes 422",                                    0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_STANDARD },    INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "hq",       "ProRes 422 HQ",                                 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_HQ },          INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "4444",     "ProRes 4444",                                   0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_4444 },        INT_MIN, INT_MAX, VE, .unit = "profile" },
+    { "xq",       "ProRes 4444 XQ",                                0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_PRORES_XQ },          INT_MIN, INT_MAX, VE, .unit = "profile" },

     COMMON_OPTIONS
     { NULL },
@@ -2848,4 +3002,5 @@
     .p.priv_class     = &prores_videotoolbox_class,
     .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
     .p.wrapper_name   = "videotoolbox",
+    .hw_configs       = vt_encode_hw_configs,
 };
Index: libavcodec/hevc_parser.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git libavcodec/hevc_parser.c libavcodec/hevc_parser.c
--- libavcodec/hevc_parser.c	(revision e389681a74defdcd337ac32b61a41aed34009fc8)
+++ libavcodec/hevc_parser.c	(date 1708801757137)
@@ -278,6 +278,8 @@
             (nut >= 41 && nut <= 44) || (nut >= 48 && nut <= 55)) {
             if (pc->frame_start_found) {
                 pc->frame_start_found = 0;
+                if (!((pc->state64 >> 6 * 8) & 0xFF))
+                    return i - 6;
                 return i - 5;
             }
         } else if (nut <= HEVC_NAL_RASL_R ||
@@ -288,6 +290,8 @@
                     pc->frame_start_found = 1;
                 } else { // First slice of next frame found
                     pc->frame_start_found = 0;
+                    if (!((pc->state64 >> 6 * 8) & 0xFF))
+                        return i - 6;
                     return i - 5;
                 }
             }
Index: libavcodec/videotoolbox.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git libavcodec/videotoolbox.c libavcodec/videotoolbox.c
--- libavcodec/videotoolbox.c	(revision e389681a74defdcd337ac32b61a41aed34009fc8)
+++ libavcodec/videotoolbox.c	(date 1708803163338)
@@ -77,8 +77,8 @@
     void *tmp;

     tmp = av_fast_realloc(vtctx->bitstream,
-                         &vtctx->allocated_size,
-                         size);
+                          &vtctx->allocated_size,
+                          size);

     if (!tmp)
         return AVERROR(ENOMEM);
@@ -548,6 +548,7 @@
         cached_frames->height != height) {
         AVBufferRef *hw_frames_ctx = av_hwframe_ctx_alloc(cached_frames->device_ref);
         AVHWFramesContext *hw_frames;
+        AVVTFramesContext *hw_ctx;
         if (!hw_frames_ctx)
             return AVERROR(ENOMEM);

@@ -556,6 +557,8 @@
         hw_frames->sw_format = sw_format;
         hw_frames->width = width;
         hw_frames->height = height;
+        hw_ctx = hw_frames->hwctx;
+        hw_ctx->color_range = avctx->color_range;

         ret = av_hwframe_ctx_init(hw_frames_ctx);
         if (ret < 0) {
@@ -799,6 +802,9 @@
 static CFDictionaryRef videotoolbox_decoder_config_create(CMVideoCodecType codec_type,
                                                           AVCodecContext *avctx)
 {
+    CFMutableDictionaryRef avc_info;
+    CFDataRef data = NULL;
+
     CFMutableDictionaryRef config_info = CFDictionaryCreateMutable(kCFAllocatorDefault,
                                                                    0,
                                                                    &kCFTypeDictionaryKeyCallBacks,
@@ -806,49 +812,46 @@

     CFDictionarySetValue(config_info,
                          codec_type == kCMVideoCodecType_HEVC ?
-                            kVTVideoDecoderSpecification_EnableHardwareAcceleratedVideoDecoder :
-                            kVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoder,
+                         kVTVideoDecoderSpecification_EnableHardwareAcceleratedVideoDecoder :
+                         kVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoder,
                          kCFBooleanTrue);

-    CFMutableDictionaryRef avc_info;
-    CFDataRef data = NULL;
-
     avc_info = CFDictionaryCreateMutable(kCFAllocatorDefault,
                                          1,
                                          &kCFTypeDictionaryKeyCallBacks,
                                          &kCFTypeDictionaryValueCallBacks);

     switch (codec_type) {
-    case kCMVideoCodecType_MPEG4Video :
-        if (avctx->extradata_size)
-            data = videotoolbox_esds_extradata_create(avctx);
-        if (data)
-            CFDictionarySetValue(avc_info, CFSTR("esds"), data);
-        break;
-    case kCMVideoCodecType_H264 :
-        data = ff_videotoolbox_avcc_extradata_create(avctx);
-        if (data)
-            CFDictionarySetValue(avc_info, CFSTR("avcC"), data);
-        break;
-    case kCMVideoCodecType_HEVC :
-        data = ff_videotoolbox_hvcc_extradata_create(avctx);
-        if (data)
-            CFDictionarySetValue(avc_info, CFSTR("hvcC"), data);
-        break;
+        case kCMVideoCodecType_MPEG4Video :
+            if (avctx->extradata_size)
+                data = videotoolbox_esds_extradata_create(avctx);
+            if (data)
+                CFDictionarySetValue(avc_info, CFSTR("esds"), data);
+            break;
+        case kCMVideoCodecType_H264 :
+            data = ff_videotoolbox_avcc_extradata_create(avctx);
+            if (data)
+                CFDictionarySetValue(avc_info, CFSTR("avcC"), data);
+            break;
+        case kCMVideoCodecType_HEVC :
+            data = ff_videotoolbox_hvcc_extradata_create(avctx);
+            if (data)
+                CFDictionarySetValue(avc_info, CFSTR("hvcC"), data);
+            break;
 #if CONFIG_VP9_VIDEOTOOLBOX_HWACCEL
-    case kCMVideoCodecType_VP9 :
-        data = ff_videotoolbox_vpcc_extradata_create(avctx);
-        if (data)
-            CFDictionarySetValue(avc_info, CFSTR("vpcC"), data);
-        break;
+        case kCMVideoCodecType_VP9 :
+            data = ff_videotoolbox_vpcc_extradata_create(avctx);
+            if (data)
+                CFDictionarySetValue(avc_info, CFSTR("vpcC"), data);
+            break;
 #endif
-    default:
-        break;
+        default:
+            break;
     }

     CFDictionarySetValue(config_info,
-            kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms,
-            avc_info);
+                         kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms,
+                         avc_info);

     if (data)
         CFRelease(data);
@@ -871,44 +874,44 @@
     }

     switch( avctx->codec_id ) {
-    case AV_CODEC_ID_H263 :
-        videotoolbox->cm_codec_type = kCMVideoCodecType_H263;
-        break;
-    case AV_CODEC_ID_H264 :
-        videotoolbox->cm_codec_type = kCMVideoCodecType_H264;
-        break;
-    case AV_CODEC_ID_HEVC :
-        videotoolbox->cm_codec_type = kCMVideoCodecType_HEVC;
-        break;
-    case AV_CODEC_ID_MPEG1VIDEO :
-        videotoolbox->cm_codec_type = kCMVideoCodecType_MPEG1Video;
-        break;
-    case AV_CODEC_ID_MPEG2VIDEO :
-        videotoolbox->cm_codec_type = kCMVideoCodecType_MPEG2Video;
-        break;
-    case AV_CODEC_ID_MPEG4 :
-        videotoolbox->cm_codec_type = kCMVideoCodecType_MPEG4Video;
-        break;
-    case AV_CODEC_ID_PRORES :
-        switch (avctx->codec_tag) {
-        default:
-            av_log(avctx, AV_LOG_WARNING, "Unknown prores profile %d\n", avctx->codec_tag);
-        // fall-through
-        case MKTAG('a','p','c','o'): // kCMVideoCodecType_AppleProRes422Proxy
-        case MKTAG('a','p','c','s'): // kCMVideoCodecType_AppleProRes422LT
-        case MKTAG('a','p','c','n'): // kCMVideoCodecType_AppleProRes422
-        case MKTAG('a','p','c','h'): // kCMVideoCodecType_AppleProRes422HQ
-        case MKTAG('a','p','4','h'): // kCMVideoCodecType_AppleProRes4444
-        case MKTAG('a','p','4','x'): // kCMVideoCodecType_AppleProRes4444XQ
-            videotoolbox->cm_codec_type = av_bswap32(avctx->codec_tag);
-            break;
-        }
-        break;
-    case AV_CODEC_ID_VP9 :
-        videotoolbox->cm_codec_type = kCMVideoCodecType_VP9;
-        break;
-    default :
-        break;
+        case AV_CODEC_ID_H263 :
+            videotoolbox->cm_codec_type = kCMVideoCodecType_H263;
+            break;
+        case AV_CODEC_ID_H264 :
+            videotoolbox->cm_codec_type = kCMVideoCodecType_H264;
+            break;
+        case AV_CODEC_ID_HEVC :
+            videotoolbox->cm_codec_type = kCMVideoCodecType_HEVC;
+            break;
+        case AV_CODEC_ID_MPEG1VIDEO :
+            videotoolbox->cm_codec_type = kCMVideoCodecType_MPEG1Video;
+            break;
+        case AV_CODEC_ID_MPEG2VIDEO :
+            videotoolbox->cm_codec_type = kCMVideoCodecType_MPEG2Video;
+            break;
+        case AV_CODEC_ID_MPEG4 :
+            videotoolbox->cm_codec_type = kCMVideoCodecType_MPEG4Video;
+            break;
+        case AV_CODEC_ID_PRORES :
+            switch (avctx->codec_tag) {
+                default:
+                    av_log(avctx, AV_LOG_WARNING, "Unknown prores profile %d\n", avctx->codec_tag);
+                    // fall-through
+                case MKTAG('a','p','c','o'): // kCMVideoCodecType_AppleProRes422Proxy
+                case MKTAG('a','p','c','s'): // kCMVideoCodecType_AppleProRes422LT
+                case MKTAG('a','p','c','n'): // kCMVideoCodecType_AppleProRes422
+                case MKTAG('a','p','c','h'): // kCMVideoCodecType_AppleProRes422HQ
+                case MKTAG('a','p','4','h'): // kCMVideoCodecType_AppleProRes4444
+                case MKTAG('a','p','4','x'): // kCMVideoCodecType_AppleProRes4444XQ
+                    videotoolbox->cm_codec_type = av_bswap32(avctx->codec_tag);
+                    break;
+            }
+            break;
+        case AV_CODEC_ID_VP9 :
+            videotoolbox->cm_codec_type = kCMVideoCodecType_VP9;
+            break;
+        default :
+            break;
     }

 #if defined(MAC_OS_X_VERSION_10_9) && !TARGET_OS_IPHONE && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_9) && AV_HAS_BUILTIN(__builtin_available)
@@ -964,26 +967,26 @@
         CFRelease(buf_attr);

     switch (status) {
-    case kVTVideoDecoderNotAvailableNowErr:
-        av_log(avctx, AV_LOG_VERBOSE, "VideoToolbox session not available.\n");
-        return AVERROR(ENOSYS);
-    case kVTVideoDecoderUnsupportedDataFormatErr:
-        av_log(avctx, AV_LOG_VERBOSE, "VideoToolbox does not support this format.\n");
-        return AVERROR(ENOSYS);
-    case kVTCouldNotFindVideoDecoderErr:
-        av_log(avctx, AV_LOG_VERBOSE, "VideoToolbox decoder for this format not found.\n");
-        return AVERROR(ENOSYS);
-    case kVTVideoDecoderMalfunctionErr:
-        av_log(avctx, AV_LOG_VERBOSE, "VideoToolbox malfunction.\n");
-        return AVERROR(EINVAL);
-    case kVTVideoDecoderBadDataErr:
-        av_log(avctx, AV_LOG_VERBOSE, "VideoToolbox reported invalid data.\n");
-        return AVERROR_INVALIDDATA;
-    case 0:
-        return 0;
-    default:
-        av_log(avctx, AV_LOG_VERBOSE, "Unknown VideoToolbox session creation error %d\n", (int)status);
-        return AVERROR_UNKNOWN;
+        case kVTVideoDecoderNotAvailableNowErr:
+            av_log(avctx, AV_LOG_ERROR, "VideoToolbox session not available.\n");
+            return AVERROR(ENOSYS);
+        case kVTVideoDecoderUnsupportedDataFormatErr:
+            av_log(avctx, AV_LOG_ERROR, "VideoToolbox does not support this format.\n");
+            return AVERROR(ENOSYS);
+        case kVTCouldNotFindVideoDecoderErr:
+            av_log(avctx, AV_LOG_ERROR, "VideoToolbox decoder for this format not found.\n");
+            return AVERROR(ENOSYS);
+        case kVTVideoDecoderMalfunctionErr:
+            av_log(avctx, AV_LOG_ERROR, "VideoToolbox malfunction.\n");
+            return AVERROR(EINVAL);
+        case kVTVideoDecoderBadDataErr:
+            av_log(avctx, AV_LOG_ERROR, "VideoToolbox reported invalid data.\n");
+            return AVERROR_INVALIDDATA;
+        case 0:
+            return 0;
+        default:
+            av_log(avctx, AV_LOG_ERROR, "Unknown VideoToolbox session creation error %d\n", (int)status);
+            return AVERROR_UNKNOWN;
     }
 }

@@ -1072,13 +1075,14 @@
     HEVCContext *h = avctx->priv_data;
     AVFrame *frame = h->ref->frame;
     VTContext *vtctx = avctx->internal->hwaccel_priv_data;
+    int ret;

     h->output_frame->crop_right = 0;
     h->output_frame->crop_left = 0;
     h->output_frame->crop_top = 0;
     h->output_frame->crop_bottom = 0;

-    int ret = ff_videotoolbox_common_end_frame(avctx, frame);
+    ret = ff_videotoolbox_common_end_frame(avctx, frame);
     vtctx->bitstream_size = 0;
     return ret;
 }
@@ -1108,15 +1112,15 @@
 }

 static int videotoolbox_prores_start_frame(AVCodecContext *avctx,
-                                         const uint8_t *buffer,
-                                         uint32_t size)
+                                           const uint8_t *buffer,
+                                           uint32_t size)
 {
     return 0;
 }

 static int videotoolbox_prores_decode_slice(AVCodecContext *avctx,
-                                          const uint8_t *buffer,
-                                          uint32_t size)
+                                            const uint8_t *buffer,
+                                            uint32_t size)
 {
     VTContext *vtctx = avctx->internal->hwaccel_priv_data;

@@ -1132,15 +1136,17 @@
 }

 static enum AVPixelFormat videotoolbox_best_pixel_format(AVCodecContext *avctx) {
+    int depth;
     const AVPixFmtDescriptor *descriptor = av_pix_fmt_desc_get(avctx->sw_pix_fmt);
     if (!descriptor)
         return AV_PIX_FMT_NV12; // same as av_videotoolbox_alloc_context()

-    int depth = descriptor->comp[0].depth;

     if (descriptor->flags & AV_PIX_FMT_FLAG_ALPHA)
         return AV_PIX_FMT_AYUV64;

+    depth = descriptor->comp[0].depth;
+
 #if HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE
     if (depth > 10)
         return descriptor->log2_chroma_w == 0 ? AV_PIX_FMT_P416 : AV_PIX_FMT_P216;
@@ -1193,12 +1199,14 @@
 {
     VTContext *vtctx = avctx->internal->hwaccel_priv_data;
     AVHWFramesContext *hw_frames;
+    AVVTFramesContext *hw_ctx;
     int err;
+    bool full_range;

     vtctx->logctx = avctx;

     if (!avctx->hw_frames_ctx && !avctx->hw_device_ctx &&
-            avctx->hwaccel_context)
+        avctx->hwaccel_context)
         return videotoolbox_start(avctx);

     if (!avctx->hw_frames_ctx && !avctx->hw_device_ctx) {
@@ -1227,6 +1235,8 @@
         hw_frames->sw_format = videotoolbox_best_pixel_format(avctx);
         hw_frames->width = avctx->width;
         hw_frames->height = avctx->height;
+        hw_ctx = hw_frames->hwctx;
+        hw_ctx->color_range = avctx->color_range;

         err = av_hwframe_ctx_init(avctx->hw_frames_ctx);
         if (err < 0) {
@@ -1241,7 +1251,7 @@
         goto fail;
     }

-    bool full_range = avctx->color_range == AVCOL_RANGE_JPEG;
+    full_range = avctx->color_range == AVCOL_RANGE_JPEG;
     vtctx->vt_ctx->cv_pix_fmt_type =
         av_map_videotoolbox_format_from_pixfmt2(hw_frames->sw_format, full_range);
     if (!vtctx->vt_ctx->cv_pix_fmt_type) {
@@ -1262,7 +1272,7 @@

     return 0;

-fail:
+    fail:
     ff_videotoolbox_uninit(avctx);
     return err;
 }
