dnl original patch provided by alllexx88 as 3689-bash-subshell-V3.patch
dnl https://midnight-commander.org/ticket/3689

--- src/subshell/common.c.org	2019-06-16 17:49:31.000000000 +0000
+++ src/subshell/common.c	2019-12-29 17:28:33.049619129 +0000
@@ -369,7 +369,7 @@
     switch (mc_global.shell->type)
     {
     case SHELL_BASH:
-        execl (mc_global.shell->path, "bash", "-rcfile", init_file, (char *) NULL);
+        execl (mc_global.shell->path, mc_global.shell->name, "-rcfile", init_file, (char *) NULL);
         break;
 
     case SHELL_ZSH:
--- lib/shell.c.org	2019-06-16 17:49:31.000000000 +0000
+++ lib/shell.c	2019-12-29 17:34:32.741113924 +0000
@@ -33,6 +33,8 @@
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <sys/wait.h>
+#include <unistd.h>
 
 #include "global.h"
 #include "util.h"
@@ -191,16 +193,56 @@
         mc_shell->type = SHELL_NONE;
 }
 
+/* ---------------------------------------------------------------------------------------------
+   This function returns TRUE for a shell if it has an internal variable with respective name.
+   We unset environmental variable of the same name in the child fork to make sure it's internal.
+   --------------------------------------------------------------------------------------------- */
+static gboolean
+mc_shell_internal_variable_isset (mc_shell_t * mc_shell, const char * name)
+{
+    pid_t cpid, w;
+    int status;
+    char *command;
+
+    command = g_strdup_printf ("([ -z \"${%s+x}\" ] && exit 1) || exit 0", name);
+
+    cpid = fork();
+    if (cpid == -1) {
+        /* failed to fork */
+        g_free (command);
+        return FALSE;
+    }
+
+   if (cpid == 0) {            /* Code executed by child */
+        unsetenv(name);
+        execl(mc_shell->path, mc_shell->path, "-c", command, (char *) NULL);
+        /* execl failed */
+        exit(1);
+   } else {                    /* Code executed by parent */
+        g_free (command);
+        do {
+            w = waitpid(cpid, &status, WUNTRACED | WCONTINUED);
+            if (w == -1) {
+                /* waitpid error */
+                return FALSE;
+            }
+        } while (!WIFEXITED(status) && !WIFSIGNALED(status));
+
+        return (WIFEXITED(status)) && (WEXITSTATUS(status) == 0);
+    }
+}
+
 /* --------------------------------------------------------------------------------------------- */
 
 static void
 mc_shell_recognize_path (mc_shell_t * mc_shell)
 {
-    /* If shell is not symlinked to busybox, it is safe to assume it is a real shell */
-    if (strstr (mc_shell->path, "/bash") != NULL || getenv ("BASH") != NULL)
+    /* If shell is not symlinked to busybox, it is safe to assume it is a real shell
+       Let's assume shell is bash if BASH internal variable is set */
+    if (mc_shell_internal_variable_isset (mc_shell, "BASH"))
     {
         mc_shell->type = SHELL_BASH;
-        mc_shell->name = "bash";
+        mc_shell->name = mc_shell->path;
     }
     else if (strstr (mc_shell->path, "/sh") != NULL || getenv ("SH") != NULL)
     {
